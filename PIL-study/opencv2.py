#!/usr/bin/python
# -*- coding:utf-8 -*-
# @Time   : 2018/11/12 21:53
# @Author : ly
# @File   : opencv2.py
"""
不同色彩空间：灰度、BGR、HSV（Hue，saturation，Value）
灰度色彩空间是通过去除色彩信息来将其转换成灰阶，灰度色彩空间对中间处理特别有效，比如人脸检测。
BGR，即蓝-绿-红色彩空间，每一个像素点都由一个三元数组来表示，分别代表蓝、绿、红三种颜色。
HSV，H（Hue）是色调，S（Saturation）是饱和度，V（Value）表示黑暗的程度（或光谱另一端的明亮程度）

傅里叶变换来介绍图像的幅度谱。图像的幅度谱是另一种图像，幅度谱图像呈现了原始图像在变化方面的一种表示：
把一幅图像中最明亮的像素放到图像中央，然后逐渐变暗，在边缘上的像素最暗。这样可以发现图像中有多少亮的像素和暗的像素，以及它们分布的百分比。
"""
# 一个高通滤波器的例子：
import cv2
import numpy as np
from scipy import ndimage

# 滤波器中的所有值加起来为0（原因：）
kernel_3x3 = np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])
kernel_5x5 = np.array([[-1, -1, -1, -1, -1], [-1, 1, 2, 1, -1], [-1, 2, 4, 2, -1], [-1, 1, 2, 1, -1], [-1, -1, -1, -1, -1]])

img = cv2.imread("resource/jp.jpg", 0)

k3 = ndimage.convolve(img, kernel_3x3)
k5 = ndimage.convolve(img, kernel_5x5)

blurred = cv2.GaussianBlur(img, (11, 11), 0)  # 通过图像通过低通滤波器之后，和原图像计算差值，效果比前面直接使用高通滤波器要好的多。
g_hpf = img - blurred
cv2.imshow("3x3", k3)
cv2.imshow("5x5", k5)
cv2.imshow("g_hpf", g_hpf)
cv2.waitKey()
cv2.destroyAllWindows()

"""
高通滤波器和低通滤波器的区别：
高通滤波器是根据像素与邻近像素的亮度差值来提升像素的亮度。
低通滤波器（Low Pass Filter，LPF)则是在像素与周围像素的亮度差值小于一个特定值时，平滑该像素的亮度。它主要用于去噪和模糊化，比如说，高斯模糊是最常用的模糊滤波器（平滑滤波器）之一，它是一个削弱高频信号强度的低通滤波器。
"""

"""
opencv提供了许多边缘检测滤波函数，包括Laplacian(),Sobel(),Scharr()。这些滤波函数都会将非边缘区域转化为白色或其它饱和的颜色。但是，这些函数都容易将噪声错误地识别为边缘。
缓解这个问题的方法是找到边缘之前对图像进行模糊处理。opencv提供了许多模糊滤波函数，包括blur()（简单的算术平均）、medianBlur()以及GaussianBlur()。边缘检测滤波函数和模糊模糊滤波函数的参数有很多。但总会有一个ksize参数，他是一个奇数，
表示滤波核的宽和高（以像素为单位）。
"""

"""
opencv预定义的许多滤波器（滤波函数）都会使用核。其实核是一组权重，它决定如何通过邻近像素点来计算新的像素点。核也称为卷积矩阵，他对一个区域的像素做调和（mix up）或卷积运算。通常基于核的滤波器（滤波函数）被称为卷积滤波器（滤波函数）。
"""

"""
注意权重加起来为1，如果不想改变图像的亮度就应该这样。如果稍稍修改一下锐化核，使他的权重加起来为0，就会得到一个边缘检测核，把边缘转为白色，把非边缘区域转为黑色。
"""

"""
下面构建一个模糊滤波器。为了达到模糊效果，通常权重和应该为1，而且邻近像素的权重全为正。
"""

"""
锐化、边缘检测及模糊滤波器都是用了高度对称的核。但是有时不对称的核也会得到一些有趣的效果。下面介绍一种核。它同时具有模糊（有正的权重）和锐化（有负的权重）的作用。这会产生一种脊状（ridge）或者浮雕（embossed）的效果。
"""




